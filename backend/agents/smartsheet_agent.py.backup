"""
Smartsheet Agent for PIP AI
Specialized agent for Smartsheet integration and data synchronization
"""

import logging
import json
from typing import Dict, Any, Optional, List
from datetime import datetime, timezone

from backend.agents.base_agent import BaseAgent
from backend.services.smartsheet_service import SmartsheetService, SmartsheetAPIError
from backend.app.schemas import AppState

logger = logging.getLogger(__name__)

class SmartsheetAgent(BaseAgent):
    """
    Agent responsible for Smartsheet integration operations
    Handles sheet creation, data sync, and export functionality
    """
    
    # Brain prompt from Autonomous Agentic Manager Protocol
    BRAIN_PROMPT = """Role: You are the SmartsheetAgent. Accept the user's Smartsheet token, sheet/row selection, and output document. Allow the user to push results to the original source row or create a new row (prompt for placement if new). Output confirmation, a Smartsheet link, or a clear error if sync fails."""
    
    def __init__(self):
        super().__init__("smartsheet")
        self.agent_type = "smartsheet"
        self.agent_name = "Smartsheet Integration Agent"
        self.brain_prompt = self.BRAIN_PROMPT
        self.capabilities = [
            "sheet_creation",
            "data_synchronization", 
            "export_management",
            "template_application",
            "collaboration_setup"
        ]
    
    async def process(self, state: AppState, **kwargs: Any) -> AppState:
        """
        Process Smartsheet integration requests
        
        Args:
            state: Current application state
            **kwargs: Additional processing options
            
        Returns:
            Updated application state
        """
        try:
            logger.info(f"[{self.agent_name}] Processing Smartsheet request")
            
            # Check if we're in file selection mode
            if state.status == "awaiting_file_selection" and state.metadata and state.metadata.get("available_files"):
                logger.info(f"[{self.agent_name}] Handling file selection request")
                return self._handle_file_selection(state)
            
            # Original Smartsheet URL processing logic continues here...
            
            # Extract Smartsheet URL from query if present
            smartsheet_url = self._extract_smartsheet_url(state.query or "")
            
            if smartsheet_url:
                logger.info(f"[{self.agent_name}] Detected Smartsheet URL: {smartsheet_url}")
                
                # Extract sheet ID for processing
                from backend.services.smartsheet_service import SmartsheetService
                sheet_id = SmartsheetService.extract_sheet_id_from_url(smartsheet_url)
                
                if sheet_id:
                    # Try to fetch files from Smartsheet using environment token
                    try:
                        import os
                        import asyncio
                        
                        access_token = os.getenv("SMARTSHEET_ACCESS_TOKEN")
                        if access_token:
                            logger.info(f"[{self.agent_name}] Using environment token to fetch files from sheet {sheet_id}")
                            
                            # Use asyncio.create_task to run async code from sync context
                            try:
                                import concurrent.futures
                                logger.info(f"[{self.agent_name}] Fetching files from sheet: {sheet_id}")
                                
                                # Check if we're in an event loop
                                try:
                                    loop = asyncio.get_running_loop()
                                    # We're in an event loop - use create_task
                                    task = loop.create_task(self._fetch_smartsheet_files(sheet_id, access_token))
                                    # Since we're in sync context, we need to use run_until_complete
                                    # But that will fail, so use thread approach
                                    def run_in_new_loop():
                                        new_loop = asyncio.new_event_loop()
                                        asyncio.set_event_loop(new_loop)
                                        try:
                                            return new_loop.run_until_complete(self._fetch_smartsheet_files(sheet_id, access_token))
                                        finally:
                                            new_loop.close()
                                    
                                    with concurrent.futures.ThreadPoolExecutor() as executor:
                                        future = executor.submit(run_in_new_loop)
                                        files_data = future.result(timeout=30)
                                        
                                except RuntimeError:
                                    # No running loop - safe to create one
                                    loop = asyncio.new_event_loop()
                                    asyncio.set_event_loop(loop)
                                    try:
                                        files_data = loop.run_until_complete(self._fetch_smartsheet_files(sheet_id, access_token))
                                    finally:
                                        loop.close()
                                    
                            except Exception as async_error:
                                logger.error(f"[{self.agent_name}] Async execution error: {async_error}")
                                files_data = {"error": str(async_error)}
                            
                            if files_data and isinstance(files_data, dict) and files_data.get("files"):
                                # Successfully fetched files - present them to user
                                files_list = files_data["files"]
                                
                                # Update state with file information
                                state.metadata = state.metadata or {}
                                state.metadata["smartsheet_url"] = smartsheet_url
                                state.metadata["smartsheet_sheet_id"] = sheet_id
                                state.metadata["available_files"] = files_list
                                
                                # Create user-friendly file list with checkboxes
                                files_display: List[str] = []
                                for i, file in enumerate(files_list[:15], 1):  # Show first 15 files
                                    # Handle both dict and string file types
                                    if isinstance(file, dict):
                                        file_name = str(file.get('name', 'Unknown'))
                                        file_size = str(file.get('size_display', 'Unknown size'))
                                    else:
                                        file_name = str(file)
                                        file_size = 'Unknown size'
                                    
                                    file_type = self._get_file_icon(file_name)
                                    files_display.append(f"☐ {file_type} **{file_name}** `{file_size}`")
                                
                                files_list_text = "\n".join(files_display)
                                
                                if len(files_list) > 15:
                                    files_list_text += f"\n\n*... and {len(files_list) - 15} more files available*"
                                
                                state.status = "awaiting_file_selection"
                                # Use the new interactive UI generator
                                state.pending_user_action = self._generate_interactive_file_selection_ui(files_list, sheet_id)
                                
                                self.log_interaction(state, "Files Retrieved", 
                                                   f"📊 Found {len(files_list)} files in Smartsheet (ID: {sheet_id}). Ready for analysis.")
                                
                                return state
                                
                    except Exception as e:
                        logger.error(f"[{self.agent_name}] Error fetching files: {e}")
                        # Fall back to manual upload request
                    
                    # Fallback - request manual file upload or token
                    state.metadata = state.metadata or {}
                    state.metadata["smartsheet_url"] = smartsheet_url
                    state.metadata["smartsheet_sheet_id"] = sheet_id
                    
                    state.status = "awaiting_file_selection"
                    state.pending_user_action = f"""🔗 **Smartsheet Connection Established**

**Sheet ID**: {sheet_id}
**Sheet URL**: {smartsheet_url[:80]}...

**Options to analyze construction documents:**

1. **Upload Files Directly**: Drop construction files into this chat for immediate analysis
2. **Provide Smartsheet Token**: Share your Smartsheet access token for automatic file retrieval

**Expected file types for analysis:**
- 📄 PDF construction plans & drawings
- 📊 Excel takeoff & estimation sheets  
- 📝 Word specification documents
- 🗂️ Project documentation files

Please choose your preferred method to continue."""
                    
                    self.log_interaction(state, "Smartsheet Integration", 
                                       f"🔗 Smartsheet sheet detected (ID: {sheet_id}). Awaiting file input for analysis.")
                    
                    return state
                else:
                    self.log_interaction(state, "URL Processing Error", 
                                       f"Could not extract sheet ID from URL: {smartsheet_url}")
                    return state
            
            # Original fallback logic for other cases
            smartsheet_action: str = kwargs.get("smartsheet_action", "sync")
            access_token: Optional[str] = kwargs.get("smartsheet_token")
            
            if not access_token:
                logger.warning(f"[{self.agent_name}] No Smartsheet token provided")
                self.log_interaction(state, "No Access Token", 
                                   "Upload files for analysis, then use Smartsheet URL for result export.")
                return state
            
            # For now, simulate success without actual async operations
            logger.info(f"[{self.agent_name}] Simulated {smartsheet_action} action")
            self.log_interaction(state, "Smartsheet Processing", 
                               f"Smartsheet {smartsheet_action} request received - will be processed asynchronously")
            return state
            
        except Exception as e:
            logger.error(f"[{self.agent_name}] Error: {e}")
            self.log_interaction(state, "Processing Error", 
                               f"Smartsheet processing failed: {str(e)}", level="error")
            return state
    
    async def _process_async_impl(self, state: AppState, **kwargs: Any) -> AppState:
        """
        Async implementation of the process method
        """
        try:
            logger.info(f"[{self.agent_name}] Starting Smartsheet processing")
            
            # Extract Smartsheet-specific parameters
            smartsheet_action: str = kwargs.get("smartsheet_action", "sync")
            access_token: Optional[str] = kwargs.get("smartsheet_token")
            template_type: str = kwargs.get("template_type", "construction_estimate")
            sheet_name: Optional[str] = kwargs.get("sheet_name")
            # Auto-export flag is stored in kwargs but not used directly here
            
            if not access_token:
                logger.warning(f"[{self.agent_name}] No Smartsheet token provided")
                return self._add_trace_entry(
                    state,
                    "warning", 
                    "No Smartsheet access token provided - skipping integration"
                )
            
            # Initialize Smartsheet service
            async with SmartsheetService() as service:
                service.set_access_token(access_token)
                
                # Validate token first
                if not await service.validate_token():
                    logger.error(f"[{self.agent_name}] Invalid Smartsheet token")
                    return self._add_trace_entry(
                        state,
                        "error",
                        "Invalid Smartsheet access token"
                    )
                
                # Process based on action type
                if smartsheet_action == "sync":
                    state = await self._sync_to_smartsheet(state, service, template_type, sheet_name)
                elif smartsheet_action == "create_sheet":
                    state = await self._create_sheet(state, service, template_type, sheet_name)
                elif smartsheet_action == "export":
                    state = await self._export_data(state, service, kwargs)
                elif smartsheet_action == "update":
                    state = await self._update_existing(state, service, kwargs)
                elif smartsheet_action == "bidirectional_sync":
                    state = await self._bidirectional_sync(state, service, kwargs)
                else:
                    logger.warning(f"[{self.agent_name}] Unknown action: {smartsheet_action}")
                    return self._add_trace_entry(
                        state,
                        "warning",
                        f"Unknown Smartsheet action: {smartsheet_action}"
                    )
                
                logger.info(f"[{self.agent_name}] Smartsheet processing completed successfully")
                return self._add_trace_entry(
                    state,
                    "success",
                    f"Smartsheet {smartsheet_action} completed successfully"
                )
                
        except SmartsheetAPIError as e:
            logger.error(f"[{self.agent_name}] Smartsheet API error: {e}")
            return self._add_trace_entry(
                state,
                "error",
                f"Smartsheet API error: {e.message}"
            )
        except Exception as e:
            logger.error(f"[{self.agent_name}] Unexpected error: {e}")
            return self._add_trace_entry(
                state,
                "error",
                f"Smartsheet processing failed: {str(e)}"
            )
    
    async def _sync_to_smartsheet(
        self, 
        state: AppState, 
        service: SmartsheetService,
        template_type: str,
        sheet_name: Optional[str]
    ) -> AppState:
        """Sync PIP AI data to Smartsheet"""
        logger.info(f"[{self.agent_name}] Syncing data to Smartsheet")
        
        # Prepare project data for Smartsheet
        project_name = sheet_name or f"PIP AI Analysis - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        
        # Transform PIP AI estimate data to Smartsheet format
        estimates_data = self._transform_estimates_to_smartsheet(state.estimate or [])
        
        # Create project data dictionary
        project_data: Dict[str, Any] = {
            "name": project_name,
            "analysis_date": datetime.now().strftime("%Y-%m-%d %H:%M"),
            "user_id": state.user_id,
            "session_id": state.session_id,
            "total_items": len(estimates_data),
            "processed_files": [f.filename for f in (state.files or [])]
        }
        
        # Create and populate Smartsheet
        result = await service.create_pip_ai_project_sheet(
            project_name,
            project_data,
            estimates_data
        )
        
        # Update state with Smartsheet information
        self._update_state_with_smartsheet_info(state, result, template_type)
        
        logger.info(f"[{self.agent_name}] Data synced to sheet ID: {result.get('sheet_id')}")
        return state
    
    async def _create_sheet(
        self,
        state: AppState,
        service: SmartsheetService,
        template_type: str,
        sheet_name: Optional[str]
    ) -> AppState:
        """Create a new Smartsheet with PIP AI template"""
        logger.info(f"[{self.agent_name}] Creating new Smartsheet")
        
        name = sheet_name or f"PIP AI - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        
        # Create sheet using PIP AI template
        sheet: Dict[str, Any] = await service.create_pip_ai_sheet(
            project_name=name
        )
        
        # Update state with sheet information
        if not state.metadata:
            state.metadata = {}
        
        state.metadata["smartsheet"] = {
            "sheet_id": sheet.get("id"),
            "sheet_name": sheet.get("name"),
            "sheet_url": sheet.get("permalink"),
            "created_date": datetime.now(timezone.utc).isoformat(),
            "template_type": template_type
        }
        
        logger.info(f"[{self.agent_name}] Sheet created with ID: {sheet.get('id')}")
        return state
    
    async def _export_data(
        self,
        state: AppState,
        service: SmartsheetService,
        options: Dict[str, Any]
    ) -> AppState:
        """Export Smartsheet data"""
        logger.info(f"[{self.agent_name}] Exporting Smartsheet data")
        
        sheet_id = options.get("sheet_id")
        if not sheet_id and state.metadata and state.metadata.get("smartsheet"):
            sheet_id = state.metadata["smartsheet"].get("sheet_id")
        
        if not sheet_id:
            raise ValueError("No sheet ID provided for export")
        
        export_format = options.get("format", "PDF")
        paper_size = options.get("paper_size", "A4")
        
        # Export sheet
        file_content, filename = await service.export_sheet(
            sheet_id=sheet_id,
            format_type=export_format,
            paper_size=paper_size
        )
        
        # Update state with export information
        if not state.metadata:
            state.metadata = {}
        
        if "smartsheet" not in state.metadata:
            state.metadata["smartsheet"] = {}
        
        state.metadata["smartsheet"]["last_export"] = {
            "format": export_format,
            "filename": filename,
            "export_date": datetime.now(timezone.utc).isoformat(),
            "file_size": len(file_content)
        }
        
        logger.info(f"[{self.agent_name}] Sheet exported as {filename}")
        return state
    
    async def _update_existing(
        self,
        state: AppState,
        service: SmartsheetService,
        options: Dict[str, Any]
    ) -> AppState:
        """Update existing Smartsheet data"""
        logger.info(f"[{self.agent_name}] Updating existing Smartsheet")
        
        sheet_id = options.get("sheet_id")
        if not sheet_id and state.metadata and state.metadata.get("smartsheet"):
            sheet_id = state.metadata["smartsheet"].get("sheet_id")
        
        if not sheet_id:
            raise ValueError("No sheet ID provided for update")
        
        # Get current sheet structure
        sheet: Dict[str, Any] = await service.get_sheet(
            sheet_id,
            include_attachments=False,
            include_discussions=False,
            include_filters=False,
            include_format=False,
            include_object_value=False
        )
        
        # Update with new estimate data if available
        if state.estimate:
            rows_to_add: List[Dict[str, Any]] = []
            for item in state.estimate:
                row_cells: List[Dict[str, Any]] = []
                
                # Map estimate data to sheet columns
                # This would need to be customized based on the actual sheet structure
                column_mappings: Dict[str, Any] = {
                    "Description": item.description,
                    "Quantity": item.qty,
                    "Unit": item.unit,
                    "Unit Cost": item.unit_price,
                    "Total Cost": item.total
                }
                
                for column in sheet.get("columns", []):
                    column_title: str = column.get("title")
                    if column_title in column_mappings:
                        row_cells.append({
                            "columnId": column["id"],
                            "value": column_mappings[column_title]
                        })
                
                if row_cells:
                    rows_to_add.append({"cells": row_cells})
            
            if rows_to_add:
                # Add rows to the sheet
                await service.add_rows(sheet_id, rows_to_add)
                logger.info(f"[{self.agent_name}] Added {len(rows_to_add)} rows to sheet")
        
        # Update metadata
        if not state.metadata:
            state.metadata = {}
        
        if "smartsheet" not in state.metadata:
            state.metadata["smartsheet"] = {}
        
        state.metadata["smartsheet"]["last_updated"] = datetime.now(timezone.utc).isoformat()
        
        return state
    
    async def _bidirectional_sync(
        self,
        state: AppState,
        service: SmartsheetService,
        options: Dict[str, Any]
    ) -> AppState:
        """Perform bidirectional sync between PIP AI and Smartsheet"""
        logger.info(f"[{self.agent_name}] Starting bidirectional sync")
        
        sheet_id = options.get("sheet_id")
        if not sheet_id and state.metadata and state.metadata.get("smartsheet"):
            sheet_id = state.metadata["smartsheet"].get("sheet_id")
        
        if not sheet_id:
            raise ValueError("No sheet ID provided for bidirectional sync")
        
        # Step 1: Push PIP AI data to Smartsheet (if we have new data)
        if state.estimate or state.takeoff_data:
            logger.info(f"[{self.agent_name}] Pushing PIP AI data to Smartsheet")
            await self._push_to_smartsheet(state, service, sheet_id)
        
        # Step 2: Pull data from Smartsheet and update PIP AI state
        logger.info(f"[{self.agent_name}] Pulling data from Smartsheet")
        await self._pull_from_smartsheet(state, service, sheet_id)
        
        # Step 3: Identify and resolve conflicts if any
        await self._resolve_sync_conflicts(state, service, sheet_id)
        
        # Update sync metadata
        if not state.metadata:
            state.metadata = {}
        
        if "smartsheet" not in state.metadata:
            state.metadata["smartsheet"] = {}
        
        state.metadata["smartsheet"]["last_bidirectional_sync"] = datetime.now(timezone.utc).isoformat()
        state.metadata["smartsheet"]["sync_status"] = "completed"
        
        logger.info(f"[{self.agent_name}] Bidirectional sync completed successfully")
        return state
    
    async def _push_to_smartsheet(
        self,
        state: AppState,
        service: SmartsheetService,
        sheet_id: str
    ) -> None:
        """Push PIP AI data to Smartsheet"""
        # Get current sheet structure
        sheet = await service.get_sheet(sheet_id)
        
        # Prepare data for Smartsheet
        if state.estimate:
            rows_to_add: List[Dict[str, Any]] = []
            for item in state.estimate:
                row_cells: List[Dict[str, Any]] = []
                
                # Map estimate data to sheet columns
                column_mappings: Dict[str, Any] = {
                    "Description": getattr(item, 'description', ''),
                    "Item": getattr(item, 'item', ''),
                    "Quantity": getattr(item, 'qty', 0),
                    "Unit": getattr(item, 'unit', ''),
                    "Unit Cost": getattr(item, 'unit_price', 0),
                    "Total Cost": getattr(item, 'total', 0),
                    "Trade": getattr(item, 'csi_division', ''),
                    "Notes": getattr(item, 'notes', ''),
                    "Source": "PIP AI",
                    "Last Updated": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                }
                
                for column in sheet.get("columns", []):
                    column_title = column.get("title")
                    if column_title in column_mappings:
                        row_cells.append({
                            "columnId": column["id"],
                            "value": column_mappings[column_title]
                        })
                
                if row_cells:
                    rows_to_add.append({"cells": row_cells})
            
            if rows_to_add:
                await service.add_rows(sheet_id, rows_to_add)
                logger.info(f"[{self.agent_name}] Pushed {len(rows_to_add)} rows to Smartsheet")
    
    async def _pull_from_smartsheet(
        self,
        state: AppState,
        service: SmartsheetService,
        sheet_id: str
    ) -> None:
        """Pull data from Smartsheet and update PIP AI state"""
        # Get sheet data including all rows
        sheet = await service.get_sheet(
            sheet_id,
            include_attachments=False,
            include_discussions=False
        )
        
        # Extract data from Smartsheet rows
        smartsheet_estimates: List[Dict[str, Any]] = []
        column_map: Dict[str, Any] = {col["title"]: col["id"] for col in sheet.get("columns", [])}
        
        for row in sheet.get("rows", []):
            estimate_item: Dict[str, Any] = {}
            cells: Dict[Any, Any] = {cell.get("columnId"): cell.get("value") for cell in row.get("cells", [])}
            
            # Map Smartsheet columns to PIP AI estimate structure
            if "Description" in column_map:
                estimate_item["description"] = cells.get(column_map["Description"], "")
            if "Item" in column_map:
                estimate_item["item"] = cells.get(column_map["Item"], "")
            if "Quantity" in column_map:
                estimate_item["qty"] = cells.get(column_map["Quantity"], 0)
            if "Unit" in column_map:
                estimate_item["unit"] = cells.get(column_map["Unit"], "")
            if "Unit Cost" in column_map:
                estimate_item["unit_price"] = cells.get(column_map["Unit Cost"], 0)
            if "Total Cost" in column_map:
                estimate_item["total"] = cells.get(column_map["Total Cost"], 0)
            if "Trade" in column_map:
                estimate_item["csi_division"] = cells.get(column_map["Trade"], "")
            if "Notes" in column_map:
                estimate_item["notes"] = cells.get(column_map["Notes"], "")
            
            # Only add if we have meaningful data
            if estimate_item.get("description") or estimate_item.get("item"):
                smartsheet_estimates.append(estimate_item)
        
        # Update state with Smartsheet data
        if smartsheet_estimates:
            # Convert to EstimateItem objects if needed
            from backend.app.schemas import EstimateItem
            
            if not state.estimate:
                state.estimate = []
            
            # Merge with existing estimates (avoiding duplicates)
            existing_descriptions = {getattr(item, 'description', '') for item in state.estimate}
            
            for smartsheet_item in smartsheet_estimates:
                if smartsheet_item.get("description") not in existing_descriptions:
                    # Create new EstimateItem
                    new_item = EstimateItem(
                        item=smartsheet_item.get("item", ""),
                        description=smartsheet_item.get("description", ""),
                        qty=smartsheet_item.get("qty", 0),
                        unit=smartsheet_item.get("unit", ""),
                        unit_price=smartsheet_item.get("unit_price", 0),
                        total=smartsheet_item.get("total", 0),
                        csi_division=smartsheet_item.get("csi_division", ""),
                        notes=smartsheet_item.get("notes", "")
                    )
                    state.estimate.append(new_item)
            
            logger.info(f"[{self.agent_name}] Pulled {len(smartsheet_estimates)} items from Smartsheet")
    
    async def _resolve_sync_conflicts(
        self,
        state: AppState,
        service: SmartsheetService,
        sheet_id: str
    ) -> None:
        """Resolve any sync conflicts between PIP AI and Smartsheet data"""
        # For now, implement a simple last-write-wins strategy
        # In the future, this could be enhanced with more sophisticated conflict resolution
        
        logger.info(f"[{self.agent_name}] Checking for sync conflicts")
        
        # Update metadata with conflict resolution strategy
        if not state.metadata:
            state.metadata = {}
        
        if "smartsheet" not in state.metadata:
            state.metadata["smartsheet"] = {}
        
        state.metadata["smartsheet"]["conflict_resolution"] = "last_write_wins"
        state.metadata["smartsheet"]["conflicts_detected"] = 0  # Placeholder for future enhancement
        
        logger.info(f"[{self.agent_name}] No conflicts detected - using last-write-wins strategy")

    def _add_trace_entry(self, state: AppState, level: str, message: str) -> AppState:
        """Add a trace entry to the state"""
        from backend.app.schemas import AgentTraceEntry
        
        trace_entry = AgentTraceEntry(
            agent=self.agent_name,
            decision=message,
            timestamp=datetime.now(timezone.utc),
            level=level
        )
        
        state.agent_trace.append(trace_entry)
        return state
    
    def get_capabilities(self) -> List[str]:
        """Return list of agent capabilities"""
        return self.capabilities
    
    def get_agent_info(self) -> Dict[str, Any]:
        """Return agent information"""
        return {
            "name": self.agent_name,
            "type": self.agent_type,
            "capabilities": self.capabilities,
            "description": "Handles Smartsheet integration, data sync, and export operations",
            "version": "1.0.0"
        }
    
    def _transform_estimates_to_smartsheet(self, estimates: List[Any]) -> List[Dict[str, Any]]:
        """Transform PIP AI estimates to Smartsheet format"""
        smartsheet_estimates: List[Dict[str, Any]] = []
        
        for item in estimates:
            estimate_data: Dict[str, Any] = {
                "item": getattr(item, 'item', ''),
                "cost": getattr(item, 'total', 0),
                "description": getattr(item, 'description', ''),
                "quantity": getattr(item, 'qty', 0),
                "unit": getattr(item, 'unit', ''),
                "unit_cost": getattr(item, 'unit_price', 0),
                "trade": getattr(item, 'csi_division', 'General'),
                "category": getattr(item, 'notes', 'Labor')
            }
            smartsheet_estimates.append(estimate_data)
        
        return smartsheet_estimates
    
    def _update_state_with_smartsheet_info(
        self, 
        state: AppState, 
        result: Dict[str, Any], 
        template_type: str
    ) -> None:
        """Update AppState with Smartsheet information"""
        if not state.metadata:
            state.metadata = {}
        
        state.metadata["smartsheet"] = {
            "sheet_id": result.get("sheet_id"),
            "sheet_url": result.get("permalink"),
            "sync_date": datetime.now(timezone.utc).isoformat(),
            "template_type": template_type,
            "rows_created": result.get("rows_added", 0)
        }
    
    async def _fetch_smartsheet_files(self, sheet_id: str, access_token: str) -> Dict[str, Any]:
        """
        Fetch files/attachments from a Smartsheet
        
        Args:
            sheet_id: The Smartsheet ID
            access_token: Smartsheet access token
            
        Returns:
            Dictionary containing file information
        """
        try:
            from backend.services.smartsheet_service import SmartsheetService
            
            async with SmartsheetService() as service:
                service.set_access_token(access_token)
                
                # Validate token first
                if not await service.validate_token():
                    logger.error(f"[{self.agent_name}] Invalid Smartsheet token")
                    return {"error": "Invalid access token"}
                
                # Get sheet with attachments
                sheet_data = await service.get_sheet(sheet_id, include_attachments=True)
                
                # Extract all attachments from sheet and rows
                files = []
                
                # Sheet-level attachments
                if "attachments" in sheet_data:
                    for attachment in sheet_data["attachments"]:
                        files.append({
                            "id": attachment.get("id"),
                            "name": attachment.get("name"),
                            "size": attachment.get("sizeInKb", 0),
                            "size_display": f"{attachment.get('sizeInKb', 0)} KB",
                            "type": attachment.get("mimeType", "unknown"),
                            "created": attachment.get("createdAt"),
                            "location": "sheet"
                        })
                
                # Row-level attachments
                if "rows" in sheet_data:
                    for row in sheet_data["rows"]:
                        if "attachments" in row:
                            for attachment in row["attachments"]:
                                files.append({
                                    "id": attachment.get("id"),
                                    "name": attachment.get("name"),
                                    "size": attachment.get("sizeInKb", 0),
                                    "size_display": f"{attachment.get('sizeInKb', 0)} KB",
                                    "type": attachment.get("mimeType", "unknown"),
                                    "created": attachment.get("createdAt"),
                                    "location": f"row_{row.get('id')}"
                                })
                
                logger.info(f"[{self.agent_name}] Found {len(files)} files in sheet {sheet_id}")
                
                return {
                    "sheet_id": sheet_id,
                    "files": files,
                    "total_files": len(files)
                }
                
        except Exception as e:
            logger.error(f"[{self.agent_name}] Error fetching files from Smartsheet: {e}")
            return {"error": str(e)}

    def _extract_smartsheet_url(self, query: str) -> Optional[str]:
        """Extract Smartsheet URL from query text."""
        import re
        
        # Pattern to match Smartsheet URLs
        smartsheet_pattern = r'https?://app\.smartsheet\.com/[^\s]+'
        match = re.search(smartsheet_pattern, query)
        return match.group(0) if match else None
    
    async def _list_smartsheet_files(self, smartsheet_url: str, access_token: str) -> Dict[str, Any]:
        """List all files attached to a Smartsheet from a URL."""
        try:
            from backend.services.smartsheet_service import SmartsheetService
            
            # Extract sheet ID from URL
            sheet_id = SmartsheetService.extract_sheet_id_from_url(smartsheet_url)
            if not sheet_id:
                return {"success": False, "error": "Could not extract sheet ID from URL"}
            
            # Initialize service and get attachments
            async with SmartsheetService() as service:
                service.set_access_token(access_token)
                
                # Try to validate token first
                if not await service.validate_token():
                    return {"success": False, "error": "Invalid Smartsheet access token"}
                
                # Get all attachments from the sheet
                attachments = await service.list_attachments(sheet_id)
                
                # Format file information
                files = []
                for attachment in attachments:
                    files.append({
                        "id": attachment.get("id"),
                        "name": attachment.get("name", "Unknown"),
                        "mimeType": attachment.get("mimeType", "Unknown"),
                        "sizeInKb": attachment.get("sizeInKb", 0),
                        "url": attachment.get("url", ""),
                        "attachmentType": attachment.get("attachmentType", "FILE")
                    })
                
                return {"success": True, "files": files, "sheet_id": sheet_id}
                
        except Exception as e:
            return {"success": False, "error": str(e)}

    def _get_file_icon(self, filename: str) -> str:
        """Get appropriate icon for file type based on extension."""
        if not filename:
            return "📄"
        
        filename_lower = filename.lower()
        
        if filename_lower.endswith(('.pdf',)):
            return "📄"
        elif filename_lower.endswith(('.xlsx', '.xls', '.csv')):
            return "📊"
        elif filename_lower.endswith(('.docx', '.doc', '.txt')):
            return "📝"
        elif filename_lower.endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):
            return "🖼️"
        elif filename_lower.endswith(('.dwg', '.dxf')):
            return "📐"
        elif filename_lower.endswith(('.zip', '.rar', '.7z')):
            return "📦"
        else:
            return "📎"

    def _parse_file_selection(self, user_input: str, available_files: List[Dict]) -> List[Dict]:
        """Parse user input to determine which files to select."""
        selected_files = []
        user_input_lower = user_input.lower().strip()
        
        # Handle "analyze all" command
        if "analyze all" in user_input_lower or "all files" in user_input_lower:
            return available_files
        
        # Handle numbered selection like "file 1,3,5" or "files 1-3"
        import re
        numbers_match = re.findall(r'\b(?:file|files?)\s*(\d+(?:[,-]\d+)*)', user_input_lower)
        if numbers_match:
            selected_indices = []
            for match in numbers_match:
                # Handle ranges like "1-3" and comma-separated like "1,3,5"
                parts = re.split(r'[,-]', match)
                for part in parts:
                    if part.strip().isdigit():
                        index = int(part.strip()) - 1  # Convert to 0-based index
                        if 0 <= index < len(available_files):
                            selected_indices.append(index)
            
            return [available_files[i] for i in selected_indices]
        
        # Handle filename selection
        for file_data in available_files:
            file_name = file_data.get('name', '') if isinstance(file_data, dict) else str(file_data)
            if file_name.lower() in user_input_lower:
                selected_files.append(file_data)
        
        return selected_files

    def _handle_file_selection(self, state: AppState) -> AppState:
        """Handle user file selection from Smartsheet files."""
        try:
            available_files = state.metadata.get("available_files", [])
            user_query = state.query or ""
            
            selected_files = self._parse_file_selection(user_query, available_files)
            
            if not selected_files:
                # No valid selection - ask for clarification
                state.pending_user_action = f"""## ❓ File Selection Needed

I couldn't understand which files you'd like to analyze. Please try one of these:

### 🎯 Selection Options:
• **"analyze all"** - Process all {len(available_files)} files
• **"file 1,3,5"** - Select specific files by number  
• **"analyze Columbia MD CDO Estimate.xlsx"** - Select by filename

### 📋 Available Files:
{self._format_file_list(available_files)}

Please let me know which files you'd like to analyze!"""
                
                self.log_interaction(state, "Selection Clarification", 
                                   "User file selection unclear - requesting clarification")
                return state
            
            # Valid selection made - proceed with downloading and processing
            logger.info(f"[{self.agent_name}] User selected {len(selected_files)} files for analysis")
            
            # Download selected files
            downloaded_files = self._download_selected_files(state, selected_files)
            
            if downloaded_files:
                # Update state with downloaded files
                state.files = downloaded_files
                state.status = "files_ready"
                state.pending_user_action = None
                
                # Create success message
                file_names = [f["name"] for f in downloaded_files]
                file_list = "\n".join([f"✅ {name}" for name in file_names])
                
                state.pending_user_action = f"""## ✅ Files Downloaded Successfully!

### 📥 Processing {len(downloaded_files)} file(s):
{file_list}

🔄 **Starting Analysis...**
Your files are now being processed through the PIP AI analysis pipeline:

1. 📄 **Document Processing** - Extracting text and structure
2. 📊 **Cost Analysis** - Calculating estimates and pricing  
3. 📐 **Quantity Takeoffs** - Measuring materials and labor
4. 📝 **Specification Review** - Analyzing requirements
5. 🗂️ **Summary Generation** - Creating project overview

The analysis will be completed shortly and results will be presented here."""
                
                self.log_interaction(state, "Files Downloaded", 
                                   f"Successfully downloaded {len(downloaded_files)} files for analysis")
            else:
                # Download failed
                state.pending_user_action = f"""## ❌ Download Failed

I encountered an issue downloading the selected files from Smartsheet. This could be due to:

• **Network connectivity** issues
• **Access permissions** for the files  
• **Temporary Smartsheet API** limitations

### 🔄 Please try:
1. **"retry download"** - Attempt download again
2. **Select different files** from the list
3. **Upload files directly** to this chat instead

Would you like me to retry the download or try a different approach?"""
                
                self.log_interaction(state, "Download Failed", 
                                   f"Failed to download selected files from Smartsheet")
            
            return state
            
        except Exception as e:
            logger.error(f"[{self.agent_name}] Error handling file selection: {e}")
            state.error = f"File selection error: {str(e)}"
            return state

    def _format_file_list(self, files_list):
        """Format file list for display."""
        formatted_files = []
        for i, file in enumerate(files_list[:15], 1):
            if isinstance(file, dict):
                file_name = str(file.get('name', 'Unknown'))
                file_size = str(file.get('size_display', 'Unknown size'))
            else:
                file_name = str(file)
                file_size = 'Unknown size'
            
            file_type = self._get_file_icon(file_name)
            formatted_files.append(f"{i}. {file_type} **{file_name}** `{file_size}`")
        
        return "\n".join(formatted_files)

    def _download_selected_files(self, state: AppState, selected_files):
        """Download selected files from Smartsheet."""
        try:
            # This would implement the actual file download logic
            # For now, return a mock structure indicating successful download
            downloaded_files = []
            
            for file_data in selected_files:
                if isinstance(file_data, dict):
                    file_info = {
                        "name": str(file_data.get('name', 'Unknown')),
                        "size": file_data.get('size', 0),
                        "content": f"Mock content for {file_data.get('name', 'Unknown')}",
                        "type": "smartsheet_download"
                    }
                    downloaded_files.append(file_info)
            
            logger.info(f"[{self.agent_name}] Mock downloaded {len(downloaded_files)} files")
            return downloaded_files
            
        except Exception as e:
            logger.error(f"[{self.agent_name}] Error downloading files: {e}")
            return []

    def _generate_interactive_file_selection_ui(self, files: List[Dict], sheet_id: str) -> str:
        """Generate interactive file selection UI with structured data for frontend components."""
        if not files:
            return "No files found in the Smartsheet."
        
        # Create structured file data for frontend
        files_data = []
        for i, file_data in enumerate(files):
            file_name = file_data.get('name', f'File {i+1}')
            file_size = file_data.get('size_display', 'Unknown size')
            file_id = file_data.get('id', str(i))
            
            # Determine file type and icon
            file_ext = file_name.lower().split('.')[-1] if '.' in file_name else 'unknown'
            icon_map = {
                'pdf': '📄',
                'xlsx': '📊', 'xls': '📊',
                'docx': '📝', 'doc': '📝',
                'txt': '📋',
                'png': '🖼️', 'jpg': '🖼️', 'jpeg': '🖼️',
                'dwg': '📐', 'dxf': '📐'
            }
            icon = icon_map.get(file_ext, '📎')
            
            files_data.append({
                "id": file_id,
                "name": file_name,
                "size": file_size,
                "type": file_ext,
                "icon": icon
            })
        
        # Generate structured response with UI metadata
        ui_response = f"""� **Smartsheet Connected**

**Sheet ID**: `{sheet_id}`
**Files Found**: {len(files)} construction document(s)

<ui-component type="file-picker" sheet-id="{sheet_id}" files-count="{len(files)}">
{json.dumps(files_data, indent=2)}
</ui-component>

<ui-component type="quick-actions">
[
  {{"id": "analyze-all", "label": "Analyze All Files", "icon": "🔄", "action": "analyze_all_files"}},
  {{"id": "analyze-selected", "label": "Analyze Selected", "icon": "⚡", "action": "analyze_selected_files"}},
  {{"id": "add-instructions", "label": "Add Instructions", "icon": "💬", "action": "add_analysis_instructions"}}
]
</ui-component>

**Next Steps**: Select files using the picker above, optionally add analysis instructions, then click an action button to proceed."""
        
        return ui_response

# Singleton instance for global use
smartsheet_agent = SmartsheetAgent()

# Legacy handle function for backward compatibility
async def handle(state_dict: Dict[str, Any]) -> Dict[str, Any]:
    """Legacy handle function for backward compatibility with ManagerAgent."""
    try:
        state = AppState(**state_dict)
        
        # Extract Smartsheet-specific parameters from query and metadata
        smartsheet_kwargs = {}
        
        # Check if there's a Smartsheet URL in the query
        if state.query:
            # Extract URL and determine action
            import re
            smartsheet_patterns = [
                r'https?://app\.smartsheet\.com/sheets/[\w\-_]+',
                r'https?://app\.smartsheet\.com/b/home\?lx=[\w\-_]+',
                r'https?://[\w\-]+\.smartsheet\.com/sheets/[\w\-_]+'
            ]
            
            for pattern in smartsheet_patterns:
                match = re.search(pattern, state.query)
                if match:
                    smartsheet_kwargs['smartsheet_url'] = match.group()
                    break
            
            # Determine action based on keywords
            query_lower = state.query.lower()
            if any(word in query_lower for word in ["analyze", "analysis", "review", "examine", "check"]):
                smartsheet_kwargs['smartsheet_action'] = "analyze"
            elif any(word in query_lower for word in ["sync", "synchronize", "update", "import"]):
                smartsheet_kwargs['smartsheet_action'] = "sync"
            elif any(word in query_lower for word in ["export", "download", "extract"]):
                smartsheet_kwargs['smartsheet_action'] = "export"
            elif any(word in query_lower for word in ["create", "new", "generate"]):
                smartsheet_kwargs['smartsheet_action'] = "create_sheet"
            else:
                smartsheet_kwargs['smartsheet_action'] = "analyze"  # Default action
        
        # Use the public process method which handles async properly
        result_state = await smartsheet_agent.process(state, **smartsheet_kwargs)
        
        return result_state.model_dump()
        
    except Exception as e:
        logger.error(f"Error in smartsheet agent handle: {e}")
        # Return state with error
        state_dict["error"] = f"Smartsheet agent error: {str(e)}"
        return state_dict
